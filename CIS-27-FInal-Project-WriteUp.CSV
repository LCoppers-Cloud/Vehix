//
//  CIS-27-FInal-Project-WriteUp.swift
//  Vehix
//
//  Created by Loren Coppers on 5/16/25.
//



# Vehix Fleet Management System

"""

## Table of Contents
- [Problem Description](#problem-description)
- [Technical Architecture](#technical-architecture)
- [Data Structures & Algorithms](#data-structures--algorithms)
- [User Guide](#user-guide)
- [Data Storage Implementation](#data-storage-implementation)
- [Upcoming Features](#upcoming-features)
- [Complexity Analysis](#complexity-analysis)

## Problem Description

Vehix is a comprehensive fleet management system designed to solve the complex challenges faced by businesses that manage vehicle fleets. The application addresses several critical pain points:

1. **Inventory Fragmentation**: Companies struggle to maintain accurate records of parts and equipment across multiple vehicles and locations.

2. **Vehicle Maintenance Tracking**: Fleet managers often miss maintenance schedules, leading to vehicle downtime and increased repair costs.

3. **Staff & Vehicle Assignment**: Efficiently matching technicians with properly equipped vehicles is time-consuming without centralized tracking.

4. **Performance Visibility**: Lack of real-time analytics makes it difficult to identify cost-saving opportunities and efficiency improvements.

5. **GPS & Location Management**: Asset tracking across distributed geographic areas presents significant logistical challenges.

Vehix provides an integrated solution with real-time dashboards, detailed inventory tracking, staff management, vehicle assignments, maintenance alerts, and GPS location services through both Samsara integration and AirTag alternatives.

## Technical Architecture

### Core Data Model

The system is built on a SwiftData persistence layer with several interconnected models:

```
├── Vehicle           // Vehicle fleet information
├── AuthUser          // Staff and authentication
├── InventoryItem     // Parts and equipment catalog
├── StockLocationItem // Inventory with location tracking
├── VehicleAssignment // Staff-to-vehicle relationships
├── ServiceRecord     // Maintenance history
├── Task              // Work assignments
└── PurchaseOrder     // Inventory procurement
```

### Key Algorithms & Data Structures

#### 1. Monthly Data Aggregation Pipeline

The dashboard implements a sophisticated data aggregation algorithm that processes time-series data:

```swift
var monthlyRevenueData: [(month: String, amount: Double)] {
    // Early return if no data
    if serviceRecords.isEmpty { return [] }
    
    // Create a dictionary to store data by time period
    var revenueByMonth: [String: Double] = [:]
    
    // Initialize buckets for all months in range
    let currentDate = Date()
    let calendar = Calendar.current
    let dateFormatter = DateFormatter()
    dateFormatter.dateFormat = "MMM yy"
    
    // Create placeholder buckets for all months
    for monthOffset in 0..<12 {
        if let date = calendar.date(byAdding: .month, value: -monthOffset, to: currentDate) {
            let monthKey = dateFormatter.string(from: date)
            revenueByMonth[monthKey] = 0.0
        }
    }
    
    // Aggregate data into buckets
    for record in serviceRecords {
        if record.status == "Completed" {
            let serviceDate = record.startTime
            let monthKey = dateFormatter.string(from: serviceDate)
            
            if revenueByMonth[monthKey] != nil {
                let totalCost = record.laborCost + record.partsCost
                revenueByMonth[monthKey, default: 0.0] += totalCost
            }
        }
    }
    
    // Transform and sort for visualization
    let sortedData = revenueByMonth.sorted { ... }
    return sortedData.reversed().map { (month: $0.key, amount: $0.value) }
}
```

**Python Equivalent:**
```python
def get_monthly_revenue_data(service_records):
    if not service_records:
        return []
    
    # Create dictionary for aggregation
    revenue_by_month = {}
    
    # Initialize buckets
    current_date = datetime.now()
    for month_offset in range(12):
        month_date = current_date - relativedelta(months=month_offset)
        month_key = month_date.strftime("%b %y")
        revenue_by_month[month_key] = 0.0
    
    # Aggregate data
    for record in service_records:
        if record.status == "Completed":
            service_date = record.start_time
            month_key = service_date.strftime("%b %y")
            
            if month_key in revenue_by_month:
                total_cost = record.labor_cost + record.parts_cost
                revenue_by_month[month_key] += total_cost
    
    # Sort and transform for visualization
    sorted_data = sorted(revenue_by_month.items(),
                        key=lambda x: datetime.strptime(x[0], "%b %y"),
                        reverse=True)
    return [{"month": k, "amount": v} for k, v in reversed(sorted_data)]
```

#### 2. Vehicle Inventory Value Calculation and Ranking

```swift
var topVehiclesByInventoryValue: [(vehicle: AppVehicle, value: Double)] {
    let vehiclesWithInventory = vehicles.filter { $0.stockItems?.isEmpty == false }
        .map { vehicle in
            let value = vehicle.totalInventoryValue
            return (vehicle: vehicle, value: value)
        }
        .sorted { $0.value > $1.value }
        .prefix(5)
    
    return Array(vehiclesWithInventory)
}
```

**Python Equivalent:**
```python
def get_top_vehicles_by_inventory_value(vehicles):
    # Filter, transform, and sort in a functional pipeline
    vehicles_with_inventory = [
        {"vehicle": v, "value": v.total_inventory_value}
        for v in vehicles
        if v.stock_items and len(v.stock_items) > 0
    ]
    
    # Sort by value in descending order and take top 5
    sorted_vehicles = sorted(
        vehicles_with_inventory,
        key=lambda x: x["value"],
        reverse=True
    )[:5]
    
    return sorted_vehicles
```

#### 3. Multi-criteria Task Filtering

The system implements complex predicate-based filtering to categorize tasks:

```swift
tasks.filter {
    $0.status != TaskStatus.completed.rawValue &&
    $0.status != TaskStatus.cancelled.rawValue &&
    $0.dueDate < Date()
}.count
```

**Python Equivalent:**
```python
def get_overdue_tasks_count(tasks):
    return len([
        task for task in tasks
        if task.status != TaskStatus.COMPLETED
        and task.status != TaskStatus.CANCELLED
        and task.due_date < datetime.now()
    ])
```

## Data Structures & Algorithms

### Data Structures

| Structure | Implementation | Purpose |
|-----------|----------------|---------|
| **Dictionary/HashMap** | `monthlyRevenueData` | O(1) lookup for aggregate values by time period |
| **Arrays/Lists** | Collections throughout the app | Store ordered data with O(1) access by index |
| **Graph** | Vehicle-to-Staff assignments | Track relationships between entities |
| **Tree** | UI component hierarchy | Organize visual interface elements |
| **Queue** | Task prioritization | Manage pending tasks in order |

### Algorithms

| Algorithm | Implementation | Complexity |
|-----------|----------------|-----------|
| **Filtering** | `vehicles.filter { ... }` | O(n) where n is collection size |
| **Mapping** | `.map { vehicle in ... }` | O(n) transformation of each element |
| **Sorting** | `.sorted { $0.value > $1.value }` | O(n log n) for Swift's sort implementation |
| **Aggregation** | Monthly revenue calculation | O(n) to process all records |
| **Binary Search** | Used in SwiftData backend | O(log n) for indexed queries |

## User Guide

### Dashboard

The Manager Dashboard provides at-a-glance insights into your fleet operations:

1. **Key Metrics** - Monitor vehicle count, inventory value, active jobs, and open tasks
2. **Performance Charts** - Track monthly revenue and purchases
3. **Vehicle Inventory** - See top vehicles by inventory value
4. **Task Summary** - View pending, in-progress, and overdue tasks
5. **Alerts** - Get notified about low stock and overdue tasks

### Vehicle Management

1. **Add Vehicle** - Register new vehicles with make, model, year, and VIN
2. **Assign Staff** - Link vehicles to technicians
3. **Track Maintenance** - Monitor oil changes and service history
4. **GPS Tracking** - Use Samsara integration or AirTag for location tracking

### Inventory Tracking

1. **Manage Stock** - Add, update, and transfer inventory items
2. **Low Stock Alerts** - Get notified when items fall below minimum levels
3. **Vehicle Assignment** - Track which inventory is assigned to each vehicle

### Staff Management

1. **Add Staff** - Create accounts with appropriate role permissions
2. **Assign Vehicles** - Link staff to specific vehicles
3. **GPS Tracking Options** - Enable location tracking with proper disclosure
4. **Reset Passwords** - Manage account security

## Data Storage Implementation

Vehix implements robust long-term data storage through multiple mechanisms:

### SwiftData Persistence

The core data model uses Apple's SwiftData framework, which provides:

- Object-relational mapping
- Efficient querying with indexes
- Data versioning and migration
- Transaction support
- Local device persistence

```swift
@Model
final class Vehicle {
    @Attribute(.unique) var id: String
    var make: String
    var model: String
    var year: Int
    var vin: String?
    var licensePlate: String?
    var mileage: Int
    var lastOilChangeDate: Date?
    var nextOilChangeDueMileage: Int?
    var photoData: Data?
    
    // Relationships
    @Relationship(deleteRule: .cascade) var stockItems: [StockLocationItem]?
}
```

### CloudKit Integration

The app includes CloudKit integration (configured for production environments):

```swift
// Production configuration with CloudKit
let cloudKitConfig = ModelConfiguration.CloudKitDatabase(
    containerIdentifier: "iCloud.com.lcoppers.Vehix"
)
let configuration = ModelConfiguration(cloudKitDatabase: cloudKitConfig)
```

This provides:
- Cross-device syncing
- Automatic conflict resolution
- Server-backed persistence
- Sharing capabilities

### Samsara API Integration

External data is synchronized through the Samsara API:

```swift
func syncVehicle(_ vehicle: AppVehicle, completion: @escaping (Bool, String?) -> Void) {
    guard let config = config, config.isValid, config.isEnabled else {
        completion(false, "Samsara integration not enabled or invalid configuration")
        return
    }
    
    // API call implementation
}
```

## Upcoming Features

### Data Enhancements

1. **Advanced Analytics Engine**
   - Predictive maintenance algorithms using machine learning
   - Cost forecasting based on historical data
   - Route optimization using graph theory

2. **Real-time Collaboration**
   - Multi-user editing with conflict resolution
   - Real-time notifications using publish-subscribe model
   - Changes propagation via distributed event system

3. **Enhanced Data Visualization**
   - Interactive dashboard with drill-down capabilities
   - Custom reporting engine with exportable data
   - Comparative analysis across time periods

### Technical Improvements

1. **Offline-First Architecture**
   - Complete offline capability with background sync
   - Conflict resolution using operational transforms
   - Optimistic UI updates with eventual consistency

2. **Advanced Search**
   - Full-text search implementation
   - Fuzzy matching algorithms
   - Semantic search capabilities

## Complexity Analysis

### Time Complexity

| Operation | Complexity | Notes |
|-----------|------------|-------|
| Dashboard loading | O(n) | Where n is the number of data points |
| Vehicle filtering | O(n) | Linear scan of vehicle collection |
| Task sorting | O(n log n) | Swift's standard sort implementation |
| Vehicle assignment | O(1) | Direct lookup with prepared indexes |
| Inventory aggregation | O(n) | Single pass through inventory items |

### Space Complexity

| Component | Complexity | Notes |
|-----------|------------|-------|
| Vehicle tracking | O(v) | Scales with number of vehicles |
| Inventory system | O(i) | Scales with inventory items |
| Staff management | O(s) | Scales with staff count |
| Task tracking | O(t) | Scales with number of tasks |
| Overall system | O(v + i + s + t) | Linear scaling with data size |

### Algorithm Implementation Details

The most sophisticated algorithm in the system is the multi-dimensional aggregation used for performance metrics. This combines:

1. **Filtering** - O(n) to identify relevant records
2. **Grouping** - O(n) to bucket data by time period
3. **Aggregation** - O(n) to calculate totals
4. **Sorting** - O(n log n) to arrange data chronologically

This results in a practical complexity of O(n log n) where n is the number of service records and purchase orders.

---

*Vehix combines sophisticated data structures, efficient algorithms, and comprehensive persistence to deliver a powerful fleet management solution that scales with your business needs.*
"""
